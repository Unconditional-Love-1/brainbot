#.brainbot\core\senses\audio\audio_sense.py
# Created by: David Kistner(Unconditional Love)



#system imports
import os, pyttsx3, librosa, pygame, speech_recognition as sr
from datetime import datetime
#offscreen enviornment for voice
os.environ["QT_QPA_PLATFORM"] = "offscreen"




class AudioController: #controls audio imput and output


    def __init__(self, log_function=None): #AudioController initialization

        self.log = log_function or (lambda msg: print(msg))


    def listen_and_transcribe(self, timeout=5, phrase_time_limit=10): #listener and transcriber

        recognizer = sr.Recognizer()

        try:

            with sr.Microphone() as source:
                recognizer.adjust_for_ambient_noise(source)
                print("üéôÔ∏è Listening...")
                audio = recognizer.listen(source, timeout=timeout, phrase_time_limit=phrase_time_limit)

            transcript = recognizer.recognize_google(audio)
            timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
            return {
                "timestamp": timestamp,
                "text": transcript.strip()
            }

        except sr.WaitTimeoutError:
            return {
                "timestamp": datetime.utcnow().isoformat(),
                "text": "(No speech detected ‚Äî silence)"
            }

        except sr.UnknownValueError:
            return {
                "timestamp": datetime.utcnow().isoformat(),
                "text": "(Speech unintelligible)"
            }

        except sr.RequestError as e:
            return {
                "timestamp": datetime.utcnow().isoformat(),
                "text": f"(Recognition error: {e})"
            }
        except Exception as e:
            return {
                "timestamp": datetime.utcnow().isoformat(),
                "text": f"(Unexpected error: {e})"
            }

    def play_audio(self, filepath): #audio player
        
        try:

            if not os.path.exists(filepath):
                self.log(f"‚ö†Ô∏è Audio file not found: {filepath}")
                return False

            pygame.mixer.init()
            pygame.mixer.music.load(filepath)
            pygame.mixer.music.play()

            while pygame.mixer.music.get_busy():
                continue

            self.log(f"üîä Played audio: {filepath}")
            return True

        except Exception as e:
            self.log(f"‚ö†Ô∏è Failed to play audio: {e}")
            return False

    def synthesize_speech(self, text): #speech synthesizer

        try:
            engine = pyttsx3.init()

            if hasattr(self, "voice_profile"):
                pitch = self.voice_profile.get("pitch", 150)
                tempo = self.voice_profile.get("tempo", 150)
                engine.setProperty("rate", int(tempo))
                engine.setProperty("pitch", int(pitch))  # Some engines support pitch

            engine.say(text)
            engine.runAndWait()
            self.log(f"üó£Ô∏è Synthesized speech with voice profile: {text[:60]}...")
            return True

        except Exception as e:
            self.log(f"‚ö†Ô∏è Speech synthesis failed: {e}")
            return False


    def load_voice_profile(self, filepath): #voice profile loader (converts voice from .mp3)

        try:
        
            if not os.path.exists(filepath):
                self.log(f"‚ö†Ô∏è Voice file not found: {filepath}")
                return False

            # Extract pitch, tempo, and timbre features
            y, sr = librosa.load(filepath)
            pitch = librosa.yin(y, fmin=50, sr=sr).mean()
            tempo = librosa.beat.tempo(y, sr=sr)[0]
            mfcc = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13).mean(axis=1)
            self.voice_profile = {
                "pitch": pitch,
                "tempo": tempo,
                "mfcc": mfcc.tolist()
            }
            self.log(f"üéôÔ∏è Voice profile loaded from {filepath}")
            return True

        except Exception as e:
            self.log(f"‚ö†Ô∏è Failed to load voice profile: {e}")
            return False


    def voice_loop(self, cognition, timeout=5, phrase_time_limit=10):

        while True:
            transcript_data = self.listen_and_transcribe(timeout=timeout, phrase_time_limit=phrase_time_limit)
            text = transcript_data.get("text", "")

            if not text or text.startswith("("):
                continue

            self.log(f"üéß Heard: {text}")
            response = cognition.respond(text, source="voice")
            self.synthesize_speech(response)


